C51 COMPILER V9.60.7.0   DS18B20                                                           06/30/2024 23:16:02 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE DS18B20
OBJECT MODULE PLACED IN .\Objects\DS18B20.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE DS18B20.c OPTIMIZE(8,SPEED) BROWSE INCDIR(D:\Keil_v5\C51\INC\Atmel) DEBU
                    -G OBJECTEXTEND PRINT(.\Listings\DS18B20.lst) TABS(2) OBJECT(.\Objects\DS18B20.obj)

line level    source

   1          #include "DS18B20.H"
   2          
   3          // todo: 如何搜索报警的DS18B20的ROM序列号
   4          // todo: 当挂载多个从设备（DS18B20）时如何搜索ROM
   5          
   6          // 12MHz
   7          void delay5us(uchar n)
   8          {
   9   1        do
  10   1        {
  11   2          _nop_();
  12   2          _nop_();
  13   2          _nop_();
  14   2          n--;
  15   2        } while (n);
  16   1      }
  17          
  18          /**
  19           * @description: 初始化
  20           * @return {bit} ack 0应答，1无应答
  21           */
  22          bit initDS18B20()
  23          {
  24   1        bit ack = 0;
  25   1        DQ = 0;
  26   1        delay5us(96);
  27   1        DQ = 1;
  28   1        delay5us(12);
  29   1        ack = DQ;
  30   1        delay5us(60); // 太大太小都不行
  31   1        return ack;
  32   1      }
  33          
  34          /**
  35           * @description: 向DS18B20读取一字节数据
  36           * @return {uchar} dat
  37           */
  38          uchar readbyteDS18B20()
  39          {
  40   1        uchar i = 0;
  41   1        uchar dat = 0;
  42   1        for (i = 0; i < 8; i++)
  43   1        {
  44   2          DQ = 0;
  45   2          _nop_();
  46   2          _nop_();
  47   2          DQ = 1;
  48   2          dat >>= 1;
  49   2          if (DQ)
  50   2          {
  51   3            dat |= 0x80;
  52   3          }
  53   2          delay5us(11);
  54   2        }
C51 COMPILER V9.60.7.0   DS18B20                                                           06/30/2024 23:16:02 PAGE 2   

  55   1        return dat;
  56   1      }
  57          
  58          /**
  59           * @description: 向DS18B20写入一字节数据，低位在前
  60           * @param {uchar} dat
  61           * @return {*}
  62           */
  63          void writebyteDS18B20(uchar dat)
  64          {
  65   1        uchar i = 0;
  66   1        for (i = 0; i < 8; i++)
  67   1        {
  68   2          DQ = 0;
  69   2          _nop_();
  70   2          _nop_();
  71   2          DQ = dat & 0x01;
  72   2          delay5us(12);
  73   2          DQ = 1;
  74   2          dat >>= 1;
  75   2          _nop_();
  76   2          _nop_();
  77   2        }
  78   1      }
  79          
  80          /********************************************************/
  81          /*DS18B20的CRC8校验程序*/
  82          /********************************************************/
  83          /**
  84           * @description: 一字节CRC8
  85           * @param {uchar} abyte 数据
  86           * @return {uchar} crc 返回CRC校验码
  87           */
  88          uchar calcrc_1byte(uchar abyte)
  89          {
  90   1        uchar i, crc_1byte;
  91   1        crc_1byte = 0; // 设定crc_1byte初值为0
  92   1        for (i = 0; i < 8; i++)
  93   1        {
  94   2          if ((crc_1byte ^ abyte) & 0x01)
  95   2          {
  96   3            crc_1byte ^= 0x18;
  97   3            crc_1byte >>= 1;
  98   3            crc_1byte |= 0x80;
  99   3          }
 100   2          else
 101   2            crc_1byte >>= 1;
 102   2          abyte >>= 1;
 103   2        }
 104   1        return crc_1byte;
 105   1      }
 106          /**
 107           * @description: 多字节CRC8
 108           * @param {uchar} *p 数据指针
 109           * @param {uchar} len 字节数
 110           * @return {uchar} crc 返回CRC校验码
 111           */
 112          uchar calcrc_bytes(uchar *p, uchar len)
 113          {
 114   1        uchar crc = 0;
 115   1        while (len--) // len为总共要校验的字节数
 116   1        {
C51 COMPILER V9.60.7.0   DS18B20                                                           06/30/2024 23:16:02 PAGE 3   

 117   2          crc = calcrc_1byte(crc ^ *p++);
 118   2        }
 119   1        return crc;
 120   1      }
 121          
 122          /**
 123           * @description: 读取温度，如果数据传输不正确则报警间隔1s
 124           * @return {uint} temp
 125           */
 126          uint Read_temp_DS18B20()
 127          {
 128   1        uchar i = 0;
 129   1        uchar byte9[9];
 130   1        uint temp = 0;
 131   1        initDS18B20();
 132   1        writebyteDS18B20(Skip_Rom);
 133   1        writebyteDS18B20(Convert_T);
 134   1        delay1ms(100);
 135   1        initDS18B20();
 136   1        writebyteDS18B20(Skip_Rom);
 137   1        writebyteDS18B20(Read_Scratchpad);
 138   1        for (i = 0; i < 9; i++)
 139   1        {
 140   2          byte9[i] = readbyteDS18B20();
 141   2        }
 142   1        while (calcrc_bytes(&byte9, 9)) // 数据正确CRC应为0
 143   1        {
 144   2          buzzer = 0;
 145   2          delay1ms(1000);
 146   2          buzzer = 1;
 147   2          delay1ms(1000);
 148   2        }
 149   1        temp = byte9[0] | ((byte9[1] | temp) << 8);
 150   1        return temp;
 151   1      }
 152          
 153          /**
 154           * @description: 读取EEPROM中的上下限温度，高8位为上限，低8位为下限，如果数据传
             -输不正确则警报间隔2s
 155           * @return {uint} temp 上下限温度
 156           */
 157          uint Read_EEPROM_DS18B20()
 158          {
 159   1        uchar i = 0;
 160   1        uchar byte9[9];
 161   1        uint temp = 0;
 162   1        initDS18B20();
 163   1        writebyteDS18B20(Skip_Rom);
 164   1        writebyteDS18B20(Recall_EEPROM);
 165   1        initDS18B20();
 166   1        writebyteDS18B20(Skip_Rom);
 167   1        writebyteDS18B20(Read_Scratchpad);
 168   1        for (i = 0; i < 9; i++)
 169   1        {
 170   2          byte9[i] = readbyteDS18B20();
 171   2        }
 172   1        while (calcrc_bytes(&byte9, 9)) // 数据正确CRC应为0
 173   1        {
 174   2          buzzer = 0;
 175   2          delay1ms(2000);
 176   2          buzzer = 1;
 177   2          delay1ms(2000);
C51 COMPILER V9.60.7.0   DS18B20                                                           06/30/2024 23:16:02 PAGE 4   

 178   2        }
 179   1        temp = byte9[3] | ((byte9[2] | temp) << 8);
 180   1        return temp;
 181   1      }
 182          
 183          /**
 184           * @description:  向EEPROM中写入上下限温度
 185           * @param {uchar} TH 上限温度
 186           * @param {uchar} TL 下限温度
 187           * @param {uchar} precision 精度
 188           * @return {*}
 189           */
 190          void Write_Scratchpad_EEPROM_DS18B20(uchar TH, uchar TL, uchar precision)
 191          {
 192   1        initDS18B20();
 193   1        writebyteDS18B20(Skip_Rom);
 194   1        writebyteDS18B20(Write_Scratchpad);
 195   1        writebyteDS18B20(TH);
 196   1        writebyteDS18B20(TL);
 197   1        writebyteDS18B20(precision);
 198   1        initDS18B20();
 199   1        writebyteDS18B20(Skip_Rom);
 200   1        writebyteDS18B20(Copy_Scratchpad);
 201   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    406    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      25
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
