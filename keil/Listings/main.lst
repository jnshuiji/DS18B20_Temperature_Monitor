C51 COMPILER V9.60.7.0   MAIN                                                              06/27/2024 13:16:02 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(D:\Keil_v5\C51\INC\Atmel) DEBUG O
                    -BJECTEXTEND PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "TM1637.h"
   2          
   3          uchar timer = 0;    // æ—¶é—´è®¡æ¬¡
   4          uchar luminance = 8;  // é»˜è®¤äº®åº¦ä¸º8æŒ¡ï¼Œæœ€äº®
   5          uchar keynum = 0;   // æŒ‰é”®
   6          uchar tens_unit = 0;  // ååˆ†ä½
   7          uchar unit = 0;     // ä¸ªä½
   8          uchar tens_digit = 0; // åä½
   9          char TL = 0, TH = 0;  // æ¸©åº¦ä¸Šä¸‹é™
  10          
  11          /*----------------------------------------------------æ•°ç ç®¡æ®µç -------------------------------------
             ----------------*/
  12          /*å…±é˜´æ®µç     0   1     2   3     4   5     6   7     8   9     C   è´Ÿå·  ç­  å…¨äº®  */
  13          uchar sg[] = {0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F, 0x39, 0x40, 0, 0xFF};
  14          uchar sg1[] = {0xBF, 0x86, 0xDB, 0xCF, 0xE6, 0xED, 0xFD, 0x87, 0xFF, 0xEF}; // å¸¦ç‚¹å…±é˜´æ®µç 0. 1. 2. 
             -3. 4. 5. 6. 7. 8. 9.
  15          
  16          /*å…±é˜³æ®µç     0   1     2   3     4   5     6   7     8   9     C   è´Ÿå·  ç­  å…¨äº®  */
  17          // uchar sg[] = {0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90, 0xC6, 0x40, 0xBF, 0xFF, 0};
  18          // uchar sg1[] = {0x40, 0x79, 0x24, 0x30, 0x19, 0x12, 0x02, 0x78, 0x00, 0x10}; // å¸¦ç‚¹å…±é˜³æ®µç 0. 1. 
             -2. 3. 4. 5. 6. 7. 8. 9.
  19          
  20          /*----------------------------------------------------å‡½æ•°å£°æ˜----------------------------------------
             -------------*/
  21          void timer0_interrupt_init();
  22          uchar timer0_50ms();
  23          char displaytemp();
  24          char set_limit(char TH_or_TL);
  25          void setluminance();
  26          
  27          void main()
  28          {
  29   1        uchar i = 0, j = 0;       // å¾ªç¯å˜é‡
  30   1        uchar precision = precision_12; // é»˜è®¤è½¬æ¢ç²¾åº¦12ä½
  31   1        char tempreatuer = 0;     // ç”¨äºæ¯”è¾ƒæ¸©åº¦ä¸Šä¸‹é™çš„åªæœ‰ä¸ªä½å’Œåä½çš„å¸¦ç¬¦å·æ¸©åº¦æ•°æ®
  32   1      
  33   1        // å¼€å±€ä¸€è½¬æ¢ï¼Œéœ€çº¦750ms
  34   1        initDS18B20();
  35   1        writebyteDS18B20(Skip_Rom);
  36   1        writebyteDS18B20(Convert_T);
  37   1      
  38   1        // å¼€å±€ä¸€è¯»å–ï¼Œè·å–DS18B20çš„EEPROMä¸­å‚¨å­˜çš„æ¸©åº¦ä¸Šä¸‹é™
  39   1        TH = Read_EEPROM_DS18B20() >> 8;
  40   1        TL = Read_EEPROM_DS18B20();
  41   1      
  42   1        // å¼€å±€ä¸€è®¾ç½®ï¼Œè®¾ç½®äº®åº¦
  43   1        setluminanceTM1637(luminance);
  44   1        for (i = 0; i < 4; i++) // ç­‰å¾…æ¸©åº¦è½¬æ¢ï¼Œé¡ºä¾¿æµ‹è¯•æ•°ç ç®¡æ˜¯å¦æœ‰æŸå
  45   1        {
  46   2          for (j = 0; j < 4; j++)
  47   2            displayTM1637(j + 1, sg[12]);
  48   2          displayTM1637(i + 1, sg[13]);
  49   2          delay1ms(200);
  50   2        }
C51 COMPILER V9.60.7.0   MAIN                                                              06/27/2024 13:16:02 PAGE 2   

  51   1      
  52   1        // è‹¥DS18B20æ­£å¸¸é€šè®¯
  53   1        while (!initDS18B20())
  54   1        {
  55   2          keynum = keyTM1637();
  56   2          timer = timer0_50ms();
  57   2          switch (keynum)
  58   2          {
  59   3          case 1:
  60   3            /*--------------------------------------------------
  61   3                        è°ƒèŠ‚äº®åº¦
  62   3                  é•¿æŒ‰K1ä¸¤ç§’ä»¥ä¸Šè¿›å…¥äº®åº¦è°ƒèŠ‚æ¨¡å¼
  63   3                    è¿›å…¥æ­¤æ¨¡å¼åå„æŒ‰é”®åŠŸèƒ½å¦‚ä¸‹ï¼š
  64   3                K1:+1 K2:-1 K3:+2 K4:-2 K5:è®¾ç½®ç»“æŸ
  65   3                      èŒƒå›´ï¼š5~8
  66   3            --------------------------------------------------*/
  67   3            if (timer >= 40)
  68   3              setluminance();
  69   3            /*--------------------------------------------------
  70   3                      è®¾ç½®æ¸©åº¦ä¸Šé™
  71   3                  çŸ­æŒ‰K1ä¸¤ç§’ä»¥å†…è¿›å…¥æ¸©åº¦ä¸Šé™è®¾ç½®æ¨¡å¼
  72   3                    è¿›å…¥æ­¤æ¨¡å¼åå„æŒ‰é”®åŠŸèƒ½å¦‚ä¸‹ï¼š
  73   3              K1:è½¬ä¸ºæ­£æ•°ï¼Œè®¾ç½®èŒƒå›´ï¼š0~99
  74   3              K2:è½¬ä¸ºè´Ÿæ•°ï¼Œè®¾ç½®èŒƒå›´ï¼š-49~0
  75   3              K3:åä½å¾ªç¯åŠ ä¸€ï¼ŒèŒƒå›´ï¼ˆ0ä¸æ˜¾ç¤ºï¼‰ï¼šè´Ÿæ•°æ˜¯0~4ï¼›æ­£æ•°æ˜¯0~9
  76   3              K4:ä¸ªä½å¾ªç¯åŠ ä¸€ï¼ŒèŒƒå›´ï¼š0~9
  77   3              K5:è®¾ç½®ç»“æŸï¼Œå°†æ•°æ®å­˜å…¥DS18B20çš„EEPROMä¸­
  78   3            --------------------------------------------------*/
  79   3            else
  80   3            {
  81   4              TH = Read_EEPROM_DS18B20() >> 8;
  82   4              TH = set_limit(TH);
  83   4              Write_Scratchpad_EEPROM_DS18B20(TH, TL, precision);
  84   4            }
  85   3            timer = 0;
  86   3            break;
  87   3            /*--------------------------------------------------
  88   3                      è®¾ç½®æ¸©åº¦ä¸‹é™
  89   3                    æŒ‰K2è¿›å…¥æ¸©åº¦ä¸‹é™è®¾ç½®æ¨¡å¼
  90   3                    è¿›å…¥æ­¤æ¨¡å¼åå„æŒ‰é”®åŠŸèƒ½å¦‚ä¸‹ï¼š
  91   3              K1:è½¬ä¸ºæ­£æ•°ï¼Œè®¾ç½®èŒƒå›´ï¼š0~99
  92   3              K2:è½¬ä¸ºè´Ÿæ•°ï¼Œè®¾ç½®èŒƒå›´ï¼š-49~0
  93   3              K3:åä½å¾ªç¯åŠ ä¸€ï¼ŒèŒƒå›´ï¼ˆ0ä¸æ˜¾ç¤ºï¼‰ï¼šè´Ÿæ•°æ˜¯0~4ï¼›æ­£æ•°æ˜¯0~9
  94   3              K4:ä¸ªä½å¾ªç¯åŠ ä¸€ï¼ŒèŒƒå›´ï¼š0~9
  95   3              K5:è®¾ç½®ç»“æŸï¼Œå°†æ•°æ®å­˜å…¥DS18B20çš„EEPROMä¸­
  96   3            --------------------------------------------------*/
  97   3          case 2:
  98   3            TL = Read_EEPROM_DS18B20();
  99   3            TL = set_limit(TL);
 100   3            Write_Scratchpad_EEPROM_DS18B20(TH, TL, precision);
 101   3            break;
 102   3          default:
 103   3            tempreatuer = displaytemp();
 104   3            break;
 105   3          }
 106   2          // å¦‚æœæ¸©åº¦ä½äºä¸‹é™æˆ–è€…é«˜äºä¸Šé™ï¼Œè­¦æŠ¥ä¸€ç›´å“
 107   2          if (tempreatuer >= TH || tempreatuer <= TL)
 108   2          {
 109   3            buzzer = 0;
 110   3            delay1ms(100);
 111   3          }
 112   2          else
C51 COMPILER V9.60.7.0   MAIN                                                              06/27/2024 13:16:02 PAGE 3   

 113   2            buzzer = 1;
 114   2        }
 115   1        // è‹¥æ— æ³•ä¸DS18B20é€šè®¯ï¼Œåˆ™èœ‚é¸£å™¨å“5såå…³é—­
 116   1        buzzer = 0;
 117   1        delay1ms(5000);
 118   1      }
 119          
 120          /**
 121           * @description: 50mså®šæ—¶å™¨ä¸­æ–­åˆå§‹åŒ–@12.000MHz
 122           * @return {*}
 123           */
 124          void timer0_interrupt_init()
 125          {
 126   1        EA = 1;
 127   1        ET0 = 1;
 128   1        TMOD &= 0xF0; // è®¾ç½®å®šæ—¶å™¨æ¨¡å¼
 129   1        TMOD |= 0x01; // è®¾ç½®å®šæ—¶å™¨æ¨¡å¼
 130   1        TL0 = 0xB0;   // è®¾ç½®å®šæ—¶åˆå§‹å€¼
 131   1        TH0 = 0x3C;   // è®¾ç½®å®šæ—¶åˆå§‹å€¼
 132   1        TF0 = 0;    // æ¸…é™¤TF0æ ‡å¿—
 133   1        TR0 = 1;    // å®šæ—¶å™¨0å¼€å§‹è®¡æ—¶
 134   1      }
 135          
 136          /**
 137           * @description: æŒ‰é”®æŒ‰ä¸‹è®¡æ—¶ï¼Œtimer*50ms@12.000MHz
 138           * @return {uchar} timer æŒ‰é”®æŒ‰ä¸‹æ—¶é—´
 139           */
 140          uchar timer0_50ms()
 141          {
 142   1        ET0 = 0;    // å…³é—­ä¸­æ–­ï¼Œä»¥å…ä¸­æ–­ä¸TM637æ—¶åºå†²çª
 143   1        TMOD &= 0xF0; // è®¾ç½®å®šæ—¶å™¨æ¨¡å¼
 144   1        TMOD |= 0x01; // è®¾ç½®å®šæ—¶å™¨æ¨¡å¼
 145   1        timer = 0;
 146   1        while (keyTM1637())
 147   1        {
 148   2          TL0 = 0xB0; // è®¾ç½®å®šæ—¶åˆå§‹å€¼
 149   2          TH0 = 0x3C; // è®¾ç½®å®šæ—¶åˆå§‹å€¼
 150   2          TF0 = 0;  // æ¸…é™¤TF0æ ‡å¿—
 151   2          TR0 = 1;  // å®šæ—¶å™¨0å¼€å§‹è®¡æ—¶
 152   2          do
 153   2          {
 154   3          } while (!TF0);
 155   2          timer++;
 156   2        }
 157   1        TR0 = 0; // åœæ­¢è®¡æ—¶
 158   1        return timer;
 159   1      }
 160          
 161          /**
 162           * @description: æ•°ç ç®¡æ˜¾ç¤ºæ¸©åº¦
 163           * @return {}
 164           */
 165          char displaytemp()
 166          {
 167   1        char tempreatuer = 0;       // ç”¨äºæ¯”è¾ƒæ¸©åº¦ä¸Šä¸‹é™çš„åªæœ‰ä¸ªä½å’Œåä½çš„å¸¦ç¬¦å·æ¸©åº¦æ•°æ®
 168   1        int original = Read_temp_DS18B20(); // åŸå§‹æ¸©åº¦æ•°æ®ï¼Œ16ä½è¡¥ç ï¼Œé«˜5ä½ç¬¦å·ä½ï¼Œä½11æ•°æ®ä
             -½
 169   1        if (original < 0)         // è´Ÿ
 170   1        {
 171   2          unit = ((~original + 1) >> 4) % 10;        // ä¸ªä½
 172   2          tens_digit = ((~original + 1) >> 4) / 10 % 10; // åä½
 173   2          tempreatuer = ~(tens_digit * 10 + unit) + 1;   // è´Ÿæ•°åŸç å–ååŠ ä¸€å¾—è¡¥ç 
C51 COMPILER V9.60.7.0   MAIN                                                              06/27/2024 13:16:02 PAGE 4   

 174   2          displayTM1637(3, sg[unit]);
 175   2          if (tens_digit)
 176   2          {
 177   3            displayTM1637(2, sg[tens_digit]);
 178   3            displayTM1637(1, sg[11]);
 179   3          }
 180   2          else
 181   2          {
 182   3            displayTM1637(2, sg[11]);
 183   3            displayTM1637(1, sg[12]);
 184   3          }
 185   2        }
 186   1        else // æ­£
 187   1        {
 188   2          tens_unit = (0x000F & original) * 625 / 1000 % 10; // ååˆ†ä½
 189   2          unit = original / 16 % 10;               // ä¸ªä½
 190   2          tens_digit = original / 160 % 10;          // åä½
 191   2          tempreatuer = tens_digit * 10 + unit;        // æ­£æ•°åŸç è¡¥ç ä¸€è‡´
 192   2          displayTM1637(3, sg[tens_unit]);
 193   2          displayTM1637(2, sg1[unit]);
 194   2          if (tens_digit)
 195   2            displayTM1637(1, sg[tens_digit]);
 196   2          else
 197   2            displayTM1637(1, sg[12]);
 198   2        }
 199   1        displayTM1637(4, sg[10]); // å•ä½æ‘„æ°åº¦C
 200   1        delay1ms(5);        // è¿‡ä¸€ä¼šå„¿å†æ›´æ–°æ¸©åº¦ï¼Œå¦åˆ™æ•°ç ç®¡é—ªçƒ,å¤ªå¿«äº†æ—¶åºä¼šé”™ï¼Œæš‚æ—¶ä¸
             -çŸ¥ä¸ºä½•
 201   1        return tempreatuer;
 202   1      }
 203          
 204          /**
 205           * @description: è®¾ç½®é˜ˆå€¼
 206           * @param {char} TH_or_TL é˜ˆå€¼
 207           * @return {char} TH_or_TL é˜ˆå€¼
 208           */
 209          char set_limit(char TH_or_TL)
 210          {
 211   1        bit mode1 = 0; // ç¬¦å·ä½ï¼Œ1ä¸ºè´Ÿæ•°ï¼Œ0ä¸ºæ­£æ•°
 212   1        displayTM1637(4, sg[10]);
 213   1        if (TH_or_TL < 0)
 214   1        {
 215   2          mode1 = 1;
 216   2          unit = (~TH_or_TL + 1) % 10;
 217   2          tens_digit = (~TH_or_TL + 1) / 10 % 10;
 218   2        }
 219   1        else
 220   1        {
 221   2          mode1 = 0;
 222   2          unit = TH_or_TL % 10;
 223   2          tens_digit = TH_or_TL / 10 % 10;
 224   2        }
 225   1        while (keynum != 5)
 226   1        {
 227   2          if (mode1)
 228   2          {
 229   3            if (tens_digit > 4)
 230   3              tens_digit = 4;
 231   3            keynum = keyTM1637();
 232   3            while ((keynum != 1) && (keynum != 5))
 233   3            {
 234   4              if (tens_digit)
C51 COMPILER V9.60.7.0   MAIN                                                              06/27/2024 13:16:02 PAGE 5   

 235   4              {
 236   5                displayTM1637(1, sg[11]);
 237   5                displayTM1637(2, sg[tens_digit]);
 238   5                displayTM1637(3, sg[unit]);
 239   5              }
 240   4              else
 241   4              {
 242   5                displayTM1637(1, sg[12]);
 243   5                displayTM1637(2, sg[11]);
 244   5                displayTM1637(3, sg[unit]);
 245   5              }
 246   4              delay1ms(2);
 247   4              keynum = keyTM1637();
 248   4              while (keyTM1637())
 249   4                delay1ms(2);
 250   4              if (keynum == 3)
 251   4              {
 252   5                if (tens_digit == 4)
 253   5                  tens_digit = 0;
 254   5                else
 255   5                  tens_digit++;
 256   5              }
 257   4              if (keynum == 4)
 258   4              {
 259   5                if (unit == 9)
 260   5                  unit = 0;
 261   5                else
 262   5                  unit++;
 263   5              }
 264   4            }
 265   3            if (keynum == 1)
 266   3              mode1 = 0;
 267   3          }
 268   2          if (!mode1)
 269   2          {
 270   3            while ((keynum != 2) && (keynum != 5))
 271   3            {
 272   4              if (tens_digit)
 273   4              {
 274   5                displayTM1637(2, sg[tens_digit]);
 275   5                displayTM1637(3, sg[unit]);
 276   5              }
 277   4              else
 278   4              {
 279   5                displayTM1637(2, sg[12]);
 280   5                displayTM1637(3, sg[unit]);
 281   5              }
 282   4              displayTM1637(1, sg[12]);
 283   4              delay1ms(2);
 284   4              keynum = keyTM1637();
 285   4              while (keyTM1637())
 286   4                delay1ms(2);
 287   4              if (keynum == 3)
 288   4              {
 289   5                if (tens_digit == 9)
 290   5                  tens_digit = 0;
 291   5                else
 292   5                  tens_digit++;
 293   5              }
 294   4              if (keynum == 4)
 295   4              {
 296   5                if (unit == 9)
C51 COMPILER V9.60.7.0   MAIN                                                              06/27/2024 13:16:02 PAGE 6   

 297   5                  unit = 0;
 298   5                else
 299   5                  unit++;
 300   5              }
 301   4            }
 302   3            if (keynum == 2)
 303   3              mode1 = 1;
 304   3          }
 305   2        }
 306   1        TH_or_TL = tens_digit * 10 + unit;
 307   1        if (mode1)
 308   1          TH_or_TL = ~TH_or_TL + 1; // è½¬è¡¥ç 
 309   1        return TH_or_TL;
 310   1      }
 311          
 312          /**
 313           * @description:è®¾ç½®äº®åº¦
 314           * @return {*}
 315           */
 316          void setluminance()
 317          {
 318   1        displayTM1637(1, sg[12]);
 319   1        displayTM1637(2, sg[12]);
 320   1        displayTM1637(3, sg[12]);
 321   1        timer = 0;
 322   1        timer0_interrupt_init();
 323   1        while (keynum != 5)
 324   1          ;
 325   1        setluminanceTM1637(luminance);
 326   1      }
 327          
 328          #ifndef __VSCODE_C51__
 329          #define INTERRUPT(x) interrupt x
 330          #else
              #define INTERRUPT(x)
              #endif
 333          
 334          /**
 335           * @description: åˆ©ç”¨ä¸­æ–­å‡½æ•°å®ç°è¦æ›´æ”¹çš„æ•°å­—é—´éš”é—ªçƒ
 336           * @return {*}
 337           */
 338          void interrupt0_setluminance() INTERRUPT(1)
 339          {
 340   1        static bit mode = 0; // é—ªçƒæ¨¡å¼
 341   1        TR0 = 0;       // è¿›å…¥ä¸­æ–­å‡½æ•°å…³é—­è®¡æ—¶
 342   1        TL0 = 0xB0;      // è®¾ç½®å®šæ—¶åˆå§‹å€¼
 343   1        TH0 = 0x3C;      // è®¾ç½®å®šæ—¶åˆå§‹å€¼
 344   1        timer++;
 345   1        if (timer >= 10) // 0.5sé—ªçƒ
 346   1        {
 347   2          timer = 0;
 348   2          if (mode)
 349   2            displayTM1637(4, sg[luminance]);
 350   2          else
 351   2            displayTM1637(4, sg[12]);
 352   2          mode = ~mode;
 353   2        }
 354   1        keynum = keyTM1637();
 355   1        while (keyTM1637())
 356   1          delay1ms(2); // å¾ªç¯å¤ªå¿«TM1637ä¸€ç›´åœ¨è¯»å–æŒ‰é”®ï¼Œå½±å“æ•°ç ç®¡æ˜¾ç¤ºï¼Œä¼šé—ªçƒ
 357   1        switch (keynum)
 358   1        {
C51 COMPILER V9.60.7.0   MAIN                                                              06/27/2024 13:16:02 PAGE 7   

 359   2        case 1:
 360   2          if (luminance == 8)
 361   2            luminance = 5;
 362   2          else
 363   2            luminance++;
 364   2          break;
 365   2        case 2:
 366   2          if (luminance == 5)
 367   2            luminance = 8;
 368   2          else
 369   2            luminance--;
 370   2          break;
 371   2        case 3:
 372   2          switch (luminance)
 373   2          {
 374   3          case 7:
 375   3            luminance = 5;
 376   3            break;
 377   3          case 8:
 378   3            luminance = 6;
 379   3            break;
 380   3          default:
 381   3            luminance += 2;
 382   3            break;
 383   3          }
 384   2          break;
 385   2        case 4:
 386   2          switch (luminance)
 387   2          {
 388   3          case 5:
 389   3            luminance = 7;
 390   3            break;
 391   3          case 6:
 392   3            luminance = 8;
 393   3            break;
 394   3          default:
 395   3            luminance -= 2;
 396   3            break;
 397   3          }
 398   2          break;
 399   2        default:
 400   2          break;
 401   2        }
 402   1        TR0 = 1; // å¼€å§‹è®¡æ—¶
 403   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1206    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     32       8
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
